package nl.ou.dpd.gui.controller;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.layout.GridPane;
import javafx.scene.text.Text;
import nl.ou.dpd.exception.DesignPatternDetectorException;
import nl.ou.dpd.gui.model.Model;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.maven.model.Contributor;

import java.io.FileReader;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.StringTokenizer;
import java.util.stream.Collectors;

/**
 * A {@link Controller} for the about view of the application.
 *
 * @author Martin de Boer
 */
public class AboutViewController extends Controller {

    private static final Logger LOGGER = LogManager.getLogger(AboutViewController.class);

    // This property file is generated by the properties-maven-plugin in the pom.xml
    private static final String DPD_APPLICATION_PROPERTIES = "/dpd-application.properties";

    @FXML
    private Label applicationNameLabel;
    @FXML
    private Label applicationVersionLabel;

    @FXML
    private Label aboutDescriptionLabel;
    @FXML
    private GridPane aboutApplicationGridPane;

    @FXML
    private Label aboutContributersSubtitle;
    @FXML
    private GridPane aboutContributersGridPane;

    private String description;
    private String inceptionYear;
    private String applicationName;
    private String applicationVersion;
    private String organisationName;
    private String organisationUrl;
    private List<Contributor> developers;
    private List<Contributor> contributors;

    /**
     * Constructs a {@link AboutViewController} with the specified {@link Model}.
     *
     * @param model the model of the MVC pattern
     */
    public AboutViewController(Model model) {
        super(model);
    }

    /**
     * Called to initialize a controller after its root element has been completely processed.
     *
     * @param location  The location used to resolve relative paths for the root object, or
     *                  <tt>null</tt> if the location is not known.
     * @param resources The resources used to localize the root object, or <tt>null</tt> if
     */
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        this.getApplicationInformation();

        applicationNameLabel.setText(this.applicationName);
        applicationVersionLabel.setText(String.format("Version: %s (%s)", applicationVersion, inceptionYear));
        aboutDescriptionLabel.setText(tidy(description));

        showContributersInformation();
    }

    private void showContributersInformation() {
        aboutContributersSubtitle.setText("Contributors");

        int row = 0;
        for (Contributor developer : developers) {
            aboutContributersGridPane.addRow(
                    row++,
                    new Text(developer.getName()),
                    new Text(":"),
                    new Text(StringUtils.join(developer.getRoles(), ", "))
            );
        }
        for (Contributor contributor : contributors) {
            aboutContributersGridPane.addRow(
                    row++,
                    new Text(contributor.getName()),
                    new Text(":"),
                    new Text(StringUtils.join(contributor.getRoles(), ", "))
            );
        }
        aboutContributersGridPane.addRow(
                row++,
                new Text("Organisation"),
                new Text(":"),
                new Text(organisationName));
        aboutContributersGridPane.addRow(
                row,
                new Text(""),
                new Text(""),
                new Text(organisationUrl));
    }

    private void getApplicationInformation() {
        try {
            final InputStream inputStream = AboutViewController.class.getResourceAsStream(DPD_APPLICATION_PROPERTIES);
            final Properties properties = new Properties();
            properties.load(inputStream);

            description = tidy(properties.getProperty("dpd.description"));
            inceptionYear = properties.getProperty("dpd.year");
            applicationName = properties.getProperty("dpd.name");
            applicationVersion = properties.getProperty("dpd.version");
            organisationName = properties.getProperty("dpd.organisation.name");
            organisationUrl = properties.getProperty("dpd.organisation.url");
            developers = contributorList(properties.getProperty("dpd.developers"));
            contributors = contributorList(properties.getProperty("dpd.contributors"));

        } catch (Exception e) {
            final String msg = String.format("Unable to open resource '%s'.", DPD_APPLICATION_PROPERTIES);
            LOGGER.error(msg, e);
            throw new DesignPatternDetectorException(msg, e);
        }
    }

    /**
     * Converts a property string with format "Name1 [role1, ..., roleN], Name2 [role1, ..., roleM], ..." to a list of
     * {@link Contributor} objects containing the specified names and roles.
     *
     * @param propertyString a String from a property file
     * @return a {@link List} of {@link Contributor} instances
     */
    private List<Contributor> contributorList(String propertyString) {
        final List<Contributor> contributorList = new ArrayList<>();
        final StringTokenizer st = new StringTokenizer(propertyString, "]", false);
        while (st.hasMoreElements()) {
            final String contributorString = ((String) st.nextElement()).trim();
            if (contributorString.length() > 0) {
                final Contributor contributor = new Contributor();
                final int rolesIdx = contributorString.indexOf("[");
                contributor.setName(contributorString.substring(0, rolesIdx).replaceAll(",", "").trim());
                contributor.getRoles().addAll(getRoles(contributorString.substring(rolesIdx + 1)));
                contributorList.add(contributor);
            }
        }
        return contributorList;
    }

    private Collection<? extends String> getRoles(String commaSeparatedList) {
        final List<String> roles = Arrays.asList(StringUtils.split(commaSeparatedList, ","));
        return roles.stream().map(s -> s.trim()).collect(Collectors.toList());
    }

    private String tidy(String description) {
        description = description.replaceAll("\n", " ");
        while(description.contains("  ")) {
            description = description.replaceAll("  ", " ");
        }
        return description.trim();
    }
}

