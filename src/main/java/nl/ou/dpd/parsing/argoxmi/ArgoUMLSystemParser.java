package nl.ou.dpd.parsing.argoxmi;

import nl.ou.dpd.domain.SystemUnderConsideration;
import nl.ou.dpd.domain.edge.Cardinality;
import nl.ou.dpd.domain.edge.Edge;
import nl.ou.dpd.domain.edge.EdgeType;
import nl.ou.dpd.domain.node.Clazz;
import nl.ou.dpd.domain.node.DataType;
import nl.ou.dpd.domain.node.Interface;
import nl.ou.dpd.domain.node.Node;
import nl.ou.dpd.domain.node.Visibility;
import nl.ou.dpd.parsing.ParseException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.Attribute;
import javax.xml.stream.events.XMLEvent;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Stack;

/**
 * This class implements a parser for a xmi-file as generated by the ArgoUML-modelling tool (see
 * <a href="http://argouml.tigris.org/">http://argouml.tigris.org/</a>) with a structure and conditions part,
 * including parsing nodes, edges, attributes and conditions. If successful, the parsing results in a
 * {@link SystemUnderConsideration} with edges, nodes, attributes and all the necessary properties that could be read
 * from the XMI-file.
 * <p>
 * TODO: implement parsing of operations.
 *
 * @author Peter Vansweevelt
 * @author Martin de Boer
 */
public class ArgoUMLSystemParser {
    private static final Logger LOGGER = LogManager.getLogger(ArgoUMLSystemParser.class);

    //attributes of the XMI
    private static final String NAME = "name";
    private static final String ID = "xmi.id";
    private static final String VISIBILITY = "visibility";
    private static final String IS_ABSTRACT = "isAbstract";
    private static final String IDREF = "xmi.idref";
    private static final String LOWER = "lower";
    private static final String UPPER = "upper";
    private static final String IS_NAVIGABLE = "isNavigable";
    private static final String HREF = "href";

    //tags of the XMI
    private static final String MODEL = "Model";
    private static final String CLASS = "Class";
    private static final String INTERFACE = "Interface";
    private static final String ATTRIBUTE = "Attribute";
    private static final String ASSOCIATION = "Association";
    private static final String ASSOCIATION_END = "AssociationEnd";
    private static final String MULTIPLICITY_RANGE = "MultiplicityRange";
    private static final String ABSTRACTION = "Abstraction";
    private static final String DEPENDENCY = "Dependency";
    private static final String GENERALIZATION = "Generalization";
    private static final String DATATYPE = "DataType";

    private SystemUnderConsideration system;
    private List<Node> nodes;
    private Stack<XMLEvent> events = new Stack<>();

    public int getNumberOfNodes() {
        return nodes.size();
    }

    /**
     * Parses an xmi file with the specified {@code filename}.
     *
     * @param filename the name of the file to be parsed.
     * @return a new {@link SystemUnderConsideration}.
     */
    public SystemUnderConsideration parse(String filename) {
        nodes = new ArrayList<>();
        XMLInputFactory factory = XMLInputFactory.newInstance();

        try {
            InputStream input = new FileInputStream(new File(filename));
            XMLEventReader eventReader = factory.createXMLEventReader(input);
            handleEvents(eventReader);
        } catch (ParseException pe) {
            // We don't need to repackage a ParseException in a ParseException.
            // Rethrow ParseExceptions directly
            throw pe;
        } catch (Exception e) {
            final String msg = "The XMI file " + filename + " could not be parsed.";
            error(msg, e);
        }

        return system;
    }

    /**
     * General method to handle the events of the XMI.
     *
     * @param eventReader
     * @throws XMLStreamException
     */
    private void handleEvents(XMLEventReader eventReader) throws XMLStreamException {
        while (eventReader.hasNext()) {
            XMLEvent event = eventReader.nextEvent();
            handleEvent(event);
        }
    }

    /**
     * General method to handle events. Start and end elements are only handled if there is an action bound to the
     * event.
     *
     * @param event the event to handle. This can be a start element as well as an end element.
     */
    private void handleEvent(XMLEvent event) {
        if (event.isStartElement()) {
            handleStartElement(event);
        }
        if (event.isEndElement()) {
            handleEndElement(event);
        }
    }

    private void handleStartElement(XMLEvent event) {
        switch (event.asStartElement().getName().getLocalPart()) {
            case MODEL:
                // Create the SystemUnderConsideration
                system = createSystem(event);
                events.push(event);
                break;
            case CLASS:
            case INTERFACE:
                handleNodeEvent(event);
                events.push(event);
                break;
            case ATTRIBUTE:
                handleAttributeEvent(event);
                events.push(event);
                break;
            case ASSOCIATION:
                handleAssociationEvent(event);
                events.push(event);
                break;
            case ABSTRACTION:
                handleAbstraction(event);
                events.push(event);
                break;
            case GENERALIZATION:
                handleGeneralization(event);
                events.push(event);
                break;
            case ASSOCIATION_END:
                //navigability
                handleAssociationEndEvent(event);
                events.push(event);
                break;
            case MULTIPLICITY_RANGE:
                handleMultiplicityRangeEvent(event);
                events.push(event);
                break;
            case DATATYPE:
                //internal ArgoUML datatype of an attribute
                handleDatatypeEvent(event);
                events.push(event);
                break;
            case DEPENDENCY:
                handleDependencyEvent(event);
                events.push(event);
                break;
            default:
                break;
        }
    }

    private void handleEndElement(XMLEvent event) {
        switch (event.asEndElement().getName().getLocalPart()) {
            case MODEL:
            case CLASS:
            case INTERFACE:
            case ATTRIBUTE:
            case ASSOCIATION:
            case ABSTRACTION:
            case GENERALIZATION:
            case ASSOCIATION_END:
            case MULTIPLICITY_RANGE:
            case DATATYPE:
            case DEPENDENCY:
                events.pop();
            default:
                break;
        }
    }

    private void handleNodeEvent(XMLEvent event) {
        //look for the event one level higher
        switch (events.peek().asStartElement().getName().getLocalPart()) {
            case MODEL:
                //this is genuine node event
                createAndAddNode(event);
                break;
            case ASSOCIATION_END:
                //if last remembered event is associationEnd.participant, this is the type of an association end
                setLeftOrRightNode(event);
                break;
            case ABSTRACTION:
                //if last remembered event is abstraction, this is the type of an abstraction node
                setLeftOrRightNode(event);
                break;
            case GENERALIZATION:
                //if last remembered event is generalization, this is the type of an abstraction node
                setLeftOrRightNode(event);
                break;
            case ATTRIBUTE:
                //if last remembered event is attribute, set the type of the attribute
                setAttributeType(event);
                break;
            case DEPENDENCY:
                //if last remembered event is dependency, this is the type of an abstraction node
                setDependencyNode(event);
                break;
            default:
                break;
        }
    }

    /**
     * Create a new {@link SystemUnderConsideration} with the id and name that are specified in the event.
     *
     * @param event the XML event, specifies the name and the id of the {@link SystemUnderConsideration}
     * @return a new {@link SystemUnderConsideration} with the id and name specified in the event.
     */
    private SystemUnderConsideration createSystem(XMLEvent event) {
        String id = readAttributes(event).get(ID);
        String name = readAttributes(event).get(NAME);
        return new SystemUnderConsideration(id, name);
    }

    /**
     * Create an attribute WITHOUT type (null) and add it to the attributes of Node. A type will be added as a special
     * handling of the Class/Interface event.
     *
     * @param event
     */
    private void handleAttributeEvent(XMLEvent event) {
        Node node = findNodeById(readAttributes(events.peek()).get(ID));
        nl.ou.dpd.domain.node.Attribute attr = createUncompleteAttribute(event);
        node.getAttributes().add(attr);
    }

    /**
     * Ad
     *
     * @param event
     */
    //add an association
    private void handleAssociationEvent(XMLEvent event) {
        system.add(createIncompleteEdge(event));
    }

    //add an abstraction
    private void handleAbstraction(XMLEvent event) {
        if (events.peek().asStartElement().getName().getLocalPart() == MODEL) {
            Edge edge = createIncompleteEdge(event);
            edge.setRelationType(EdgeType.REALIZATION);
            system.add(edge);
        }
    }

    //add a generalization
    private void handleGeneralization(XMLEvent event) {
        if (events.peek().asStartElement().getName().getLocalPart() == MODEL) {
            Edge edge = createIncompleteEdge(event);
            edge.setRelationType(EdgeType.INHERITANCE);
            system.add(edge);
        }
    }

    /**
     * Alter the kind of asociation if necessary, based on the attributes for the event.
     *
     * @param event the association end event.
     */
    private void handleAssociationEndEvent(XMLEvent event) {
        //association directed if first node !isNavigable and second node isNavigable
        final Edge edge = getLastEdge();
        if (edge == null) {
            return;
        }

        final boolean isNavigable = "true".equals(readAttributes(event).get(IS_NAVIGABLE));
        if (edge.getRelationType() == null) {
            if (isNavigable) {
                edge.setRelationType(EdgeType.ASSOCIATION);
            } else {
                edge.setRelationType(EdgeType.ASSOCIATION_DIRECTED);
            }
        }
    }

    //set the multipicity of an association end
    private void handleMultiplicityRangeEvent(XMLEvent event) {
        Edge edge = getLastEdge();
        if (!events.empty() && events.peek().asStartElement().getName().getLocalPart().equals(ASSOCIATION_END)) {
            int lower = Integer.parseInt(readAttributes(event).get(LOWER));
            int upper = Integer.parseInt(readAttributes(event).get(UPPER));
            if (edge.getCardinalityLeft() == null) {
                edge.setCardinalityLeft(new Cardinality(lower, upper));
            } else {
                edge.setCardinalityRight(new Cardinality(lower, upper));
            }
        }
    }

    //set the type of an attribute
    private void handleDatatypeEvent(XMLEvent event) {
        //look for the event one level higher
        switch (events.peek().asStartElement().getName().getLocalPart()) {
            case ATTRIBUTE:
                //if last remembered event is attribute, set the type of the attribute
                //see http://argouml.tigris.org//profiles/uml14/default-uml14.xmi
                final Node lastNode = nodes.get(nodes.size() - 1);
                final nl.ou.dpd.domain.node.Attribute attr = lastNode.getAttributes().get(lastNode.getAttributes().size() - 1);
                final String href = readAttributes(event).get(HREF);
                final Node node = new DataType(href.substring(href.length() - 56));
                if (node != null) {
                    nodes.add(node);
                    attr.setType(node);
                }
                break;
        }
    }

    //add a dependency edge
    private void handleDependencyEvent(XMLEvent event) {
        if (events.peek().asStartElement().getName().getLocalPart() == CLASS) {
            //create an incomplete edge
            Map<String, String> attributes = readAttributes(event);
            String dependencyId = getIdOrIdref(attributes);
            if (dependencyId != null && findEdgeById(dependencyId) == null) {
                //create an incomplete edge if the edge does not exist yet
                Edge edge = new Edge(dependencyId, null, null, null);
                edge.setRelationType(EdgeType.DEPENDENCY);
                system.add(edge);
            }
        }
    }

    //Create a node with the specified id if it does not exist and add it to the nodes -list.
    //Set the properties of the (new or existing) node.
    private void createAndAddNode(XMLEvent event) {
        final Map<String, String> attributes = readAttributes(event);
        if (attributes.get(ID) != null) {
            Node node = findNodeById(attributes.get(ID));
            if (node == null) {
                //node does not exist
                node = createIncompleteNode(event);
                nodes.add(node);
            }
            if (node.getName() == null) {
                node.setName(attributes.get(NAME));
                if (event.asStartElement().getName().getLocalPart().equals(CLASS)) {
                    node.setVisibility(Visibility.valueOfIgnoreCase(attributes.get(VISIBILITY)));
                    node.setAbstract(Boolean.valueOf(attributes.get(IS_ABSTRACT)));
                }
            }
        }
    }

    private void setLeftOrRightNode(XMLEvent event) {
        Edge edge = getLastEdge();
        if (edge.getLeftNode() == null) {
            edge.setLeftNode(findNodeById(readAttributes(event).get(IDREF)));
        } else {
            edge.setRightNode(findNodeById(readAttributes(event).get(IDREF)));
        }
    }

    private void setAttributeType(XMLEvent event) {
        nl.ou.dpd.domain.node.Attribute attr = getLastNode().getAttributes().get(getLastNode().getAttributes().size() - 1);
        String idref = readAttributes(event).get(IDREF);
        Node node = findNodeById(idref);
        if (node == null) {
            node = createIncompleteNode(event);
            nodes.add(node);
        }
        attr.setType(node);

    }

    private void setDependencyNode(XMLEvent event) {
        String dependencyId = readAttributes(events.peek()).get(ID);
        String idrefNode = readAttributes(event).get(IDREF);
        Node node = findNodeById(idrefNode);
        Edge edge = findEdgeById(dependencyId);
        if (node == null) {
            node = createIncompleteNode(event);
            nodes.add(node);
        }
        if (edge.getLeftNode() == null) {
            edge.setLeftNode(findNodeById(idrefNode));
        } else {
            edge.setRightNode(findNodeById(idrefNode));
        }
    }

    private Edge createIncompleteEdge(XMLEvent event) {
        String id = readAttributes(event).get(ID);
        String name = readAttributes(event).get(NAME);
        Edge edge = new Edge(id, name, null, null);
        return edge;
    }

    /**
     * Create a new {@link Node) with given id and type.
     *
     * @param an {@link XMLEvent}
     * @return a new Node with the specified name and type.
     */
    private Node createIncompleteNode(XMLEvent event) {
        Map<String, String> attributes = readAttributes(event);
        String id = getIdOrIdref(attributes);
        if (event.asStartElement().getName().getLocalPart() == CLASS) {
            return new Clazz(id, null);
        } else {
            return new Interface(id, null);
        }
    }

    /**
     * Create a new node-attribute with the name and type specified in the Map.
     *
     * @param attributes a Map of attributes of the Attribute XML StartEvent.
     * @return a new node-attribute with the specified name and type (found in the list of Nodes).
     */
    private nl.ou.dpd.domain.node.Attribute createUncompleteAttribute(XMLEvent event) {
        Map<String, String> attributes = readAttributes(event);
        String id = attributes.get(ID);
        String name = attributes.get(NAME);
        Visibility visibility = Visibility.valueOf(attributes.get(VISIBILITY).toUpperCase());
        nl.ou.dpd.domain.node.Attribute attr = new nl.ou.dpd.domain.node.Attribute(id, name, null);
        attr.setVisibility(visibility);
        return attr;
    }

    private Node findNodeById(String id) {
        return nodes.stream()
                .filter(n -> n.getId().equals(id))
                .findFirst()
                .orElse(null);
    }

    private Edge findEdgeById(String id) {
        return system.getEdges().stream()
                .filter(edge -> edge.getId().equals(id))
                .findFirst()
                .orElse(null);
    }

    private String getIdOrIdref(Map<String, String> attributes) {
        String id = attributes.get(ID);
        if (id == null) {
            id = attributes.get(IDREF);
        }
        return id;

    }

    private Edge getLastEdge() {
        if (system.getEdges().isEmpty()) {
            return null;
        }
        return system.getEdges().get(system.getEdges().size() - 1);
    }

    private Node getLastNode() {
        return nodes.get(nodes.size() - 1);
    }

    private Map<String, String> readAttributes(XMLEvent event) {
        // Attributes Map with the attribute name as key and the attribute value as value
        Map<String, String> attributes = new HashMap<>();
        Iterator<Attribute> attrIterator = event.asStartElement().getAttributes();
        while (attrIterator.hasNext()) {
            Attribute attr = attrIterator.next();
            attributes.put(attr.getName().getLocalPart(), attr.getValue());
        }
        return attributes;
    }

    private void error(String msg, Exception cause) {
        LOGGER.error(msg, cause);
        throw new ParseException(msg, cause);
    }
}
