package nl.ou.dpd.parsing.argoxmi;

import nl.ou.dpd.domain.SystemUnderConsideration;
import nl.ou.dpd.domain.SystemUnderConsiderationGraph;
import nl.ou.dpd.domain.edge.Cardinality;
import nl.ou.dpd.domain.edge.Edge;
import nl.ou.dpd.domain.edge.EdgeType;
import nl.ou.dpd.domain.edge.Relation;
import nl.ou.dpd.domain.edge.RelationType;
import nl.ou.dpd.domain.node.Clazz;
import nl.ou.dpd.domain.node.DataType;
import nl.ou.dpd.domain.node.Interface;
import nl.ou.dpd.domain.node.Method;
import nl.ou.dpd.domain.node.Node;
import nl.ou.dpd.domain.node.Parameter;
import nl.ou.dpd.domain.node.Visibility;
import nl.ou.dpd.parsing.ParseException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.Attribute;
import javax.xml.stream.events.XMLEvent;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;

/**
 * This class implements a parser for a xmi-file as generated by the ArgoUML-modelling tool (see
 * <a href="http://argouml.tigris.org/">http://argouml.tigris.org/</a>)  If successful, the parsing results in a
 * {@link SystemUnderConsiderationGraph} with nodes as vertices and relations as edges. The Relations have one or more relationtypes 
 * describing the kinds of relations the classes have.
 *
 * @author Peter Vansweevelt
 * @author Martin de Boer
 */
public class ArgoUMLToSystemGraphParser {
    private static final Logger LOGGER = LogManager.getLogger(ArgoUMLToSystemGraphParser.class);

    //attributes of the XMI used in the parser
    private static final String NAME = "name";
    private static final String ID = "xmi.id";
    private static final String VISIBILITY = "visibility";
    private static final String IS_ABSTRACT = "isAbstract";
    private static final String IDREF = "xmi.idref";
    private static final String LOWER = "lower";
    private static final String UPPER = "upper";
    private static final String IS_NAVIGABLE = "isNavigable";
    private static final String HREF = "href";
    private static final String KIND = "kind";

    //tags of the XMI used in the parser
    private static final String MODEL = "Model";
    private static final String CLASS = "Class";
    private static final String INTERFACE = "Interface";
    private static final String ATTRIBUTE = "Attribute";
    private static final String ASSOCIATION = "Association";
    private static final String ASSOCIATION_END = "AssociationEnd";
    private static final String MULTIPLICITY_RANGE = "MultiplicityRange";
    private static final String ABSTRACTION = "Abstraction";
    private static final String DEPENDENCY = "Dependency";
    private static final String GENERALIZATION = "Generalization";
    private static final String DATATYPE = "DataType";
    private static final String OPERATION = "Operation";
    private static final String PARAMETER = "Parameter";
 

    private static final List<String> eventTags = Arrays.asList(new String[]{
            MODEL, CLASS, INTERFACE, ATTRIBUTE, ASSOCIATION, ASSOCIATION_END,
            MULTIPLICITY_RANGE, ABSTRACTION, DEPENDENCY, GENERALIZATION, DATATYPE, OPERATION,
            PARAMETER
    });

    private SystemUnderConsiderationGraph system; //The system under consideration that will be returned.
    private Stack<Node> sourceAndTarget; //used to keep track of source and target vertices. If size is 2, an edge can me made.
    private Stack<Boolean> navigabilities; //used to keep track of the isNavigable attribute which determines directed or undirected associations.
    private Stack<XMLEvent> events = new Stack<>(); //holds the passed events. Used to keep track of the hierarchical structure of the XMI-tags.
    Node lastNode; //holds the information of the last node.
    Relation lastRelation; //holds the information of the last Relation.
    Method lastMethod; //holds the information of the last Method.
    Parameter lastParameter; //holds the information of the last Parameter.
    nl.ou.dpd.domain.node.Attribute lastAttribute;  //holds the information of the last Attribute.
 
    /**
     * Parses an xmi file with the specified {@code filename}.
     *
     * @param filename the name of the file to be parsed.
     * @return a new {@link SystemUnderConsideration}.
     */
    public SystemUnderConsiderationGraph parse(String filename) {
        navigabilities = new Stack<>();
        sourceAndTarget = new Stack<>();
        
        XMLInputFactory factory = XMLInputFactory.newInstance();

        try {
            InputStream input = new FileInputStream(new File(filename));
            XMLEventReader eventReader = factory.createXMLEventReader(input);
            handleEvents(eventReader);
        } catch (ParseException pe) {
            // We don't need to repackage a ParseException in a ParseException.
            // Rethrow ParseExceptions directly
            throw pe;
        } catch (Exception e) {
            final String msg = "The XMI file " + filename + " could not be parsed.";
            error(msg, e);
        }
        return system;
    }

    /**
     * General method to handle the events of the XMI.
     *
     * @param eventReader
     * @throws XMLStreamException
     */
    private void handleEvents(XMLEventReader eventReader) throws XMLStreamException {
        while (eventReader.hasNext()) {
            XMLEvent event = eventReader.nextEvent();
            handleEvent(event);
        }
    }

    /**
     * General method to handle events. Start and end elements are only handled if there is an action bound to the
     * event.
     *
     * @param event the event to handle. This can be a start element as well as an end element.
     */
    private void handleEvent(XMLEvent event) {
        if (event.isStartElement()) {
            handleStartElement(event);
        }
        if (event.isEndElement()) {
            handleEndElement(event);
        }
    }

    private void handleStartElement(XMLEvent event) {
        switch (getStartElementNameLocalPart(event)) {
            case MODEL:
                // Create the SystemUnderConsideration
                system = createSystem(event);
                events.push(event);
                break;
            case CLASS:
            case INTERFACE:
                handleNodeEvent(event);
                events.push(event);
                break;
            case ATTRIBUTE:
               handleAttributeEvent(event);
                events.push(event);
                break;
            case OPERATION:
                handleOperationEvent(event);
                events.push(event);
                break;
            case PARAMETER:
            	handleParameterEvent(event);
            	events.push(event);
            	break;
            case DATATYPE:
                //internal ArgoUML datatype of an attribute
                handleDatatypeEvent(event);
                events.push(event);
                break;
           case ASSOCIATION:
                handleAssociationEvent(event);
                events.push(event);
                break;
            case ABSTRACTION:
            case GENERALIZATION:
                handleInheritance(event);
                events.push(event);
                break;
            case ASSOCIATION_END:
                handleAssociationEndEvent(event);
                events.push(event);
                break;
                case DEPENDENCY:
                handleDependencyEvent(event);
                events.push(event);
                break;
           case MULTIPLICITY_RANGE:
               handleMultiplicityRangeEvent(event);
               events.push(event);
               break;
           default:
                break;
        }
    }

    /**
     * Remove the event from the stack.
     * @param event
     */
	private void handleEndElement(XMLEvent event) {
        if (eventTags.contains(event.asEndElement().getName().getLocalPart())) {
            events.pop();
        }
    }

	/**
     * Create a new {@link SystemUnderConsiderationGraph} with the id and name that are specified in the event.
     *
     * @param event the XML event, specifies the name and the id of the {@link SystemUnderConsiderationGraph}
     * @return a new {@link SystemUnderConsiderationGraph} with the id and name specified in the event.
     */
    private SystemUnderConsiderationGraph createSystem(XMLEvent event) {
        String id = readAttributes(event).get(ID);
        String name = readAttributes(event).get(NAME);
        return new SystemUnderConsiderationGraph(id, name);
    }

    /**
     * Handles the attribute and Interface events, based on the event on level higher. 
     * @param event
     */
    private void handleNodeEvent(XMLEvent event) {
        //look for the event one level higher
        switch (getParentElementNameLocalPart()) {
            case MODEL:
                createAndAddNode(event);
                break;
            case ASSOCIATION_END:
            case ABSTRACTION:
            case GENERALIZATION:
            case DEPENDENCY:
                setSourceOrTargetNode(event);
                break;
            case ATTRIBUTE:
                setAttributeType(event);
                break;
            case PARAMETER:
            	setParameterType(event);
            default:
                break;
        }
    }

    /**
     * Create an attribute WITHOUT type (null) and add it to the attributes of Node. A type will be added as a special
     * handling of the Class/Interface event.
     *
     * @param event
     */
    private void handleAttributeEvent(XMLEvent event) {
    	//add the attribute to the attributes of the parent-node
    	lastNode = findSystemNodeById(readAttributes(events.peek()).get(ID));
        lastAttribute = createIncompleteAttribute(event);
        lastNode.getAttributes().add(lastAttribute);
    }

	/**
	 * Handles operation event based on the event on elevel higher.
	 * If the Operation belongs to a class or Interface event, create it and add it to the Class/Interface.
	 * @param event
	 * TODO handle operations in comments
	 */
	private void handleOperationEvent(XMLEvent event) {
        switch (getParentElementNameLocalPart())  {
	        case CLASS:
	        case INTERFACE:
		        //add the method to the methods of the parent-node
	        	lastNode = findSystemNodeById(readAttributes(events.peek()).get(ID));
		        lastMethod = createIncompleteMethod(event);
		        lastNode.addMethod(lastMethod);
		        break;
	        default:
	        	break;
        }
	}

	/**
	 * Handles parameters of operations(methods).
	 * If it is an 'in' parameter (no return), the parameter is added to the parameter of the method.
	 * @param event
	 */
	private void handleParameterEvent(XMLEvent event) {
		//add the attribute to the attributes of the parent-node
		Map<String, String> attributes = readAttributes(event);
		String kind = attributes.get(KIND);
		if (kind.equals("in")) {
			lastParameter = new Parameter(attributes.get(ID), attributes.get(NAME), null);
			lastMethod.addParameter(lastParameter);
		}
	}

    /**
     * Handles the types embedded in ArgoUML (a kind of primitive types.
     * see the <a href="http://argouml.tigris.org//profiles/uml14/default-uml14.xmi">webpage</a> for mare details.
     * No Relation will be set.
     * @param event
     */
    private void handleDatatypeEvent(XMLEvent event) {
        //look for the event one level higher
    	String href;
    	Node node;
        href = readAttributes(event).get(HREF);
        node = new DataType(href.substring(href.length() - 56));
        switch (getParentElementNameLocalPart()) {
            case ATTRIBUTE:
                lastAttribute.setType(node);
                break;
                //no relation is set
            case PARAMETER:
            	lastParameter.setType(node);
            	break;
            	//no relation is set
            default:
        }
    }
    
    /**
     * Find or create an {@link Relation} and add the {@link RelationType}.
     * @param event
     */
    private void handleAssociationEvent(XMLEvent event) {
        final String id = readAttributes(event).get(ID);
        final String name = readAttributes(event).get(NAME);
    	lastRelation = findSystemRelationById(id);
    	if (lastRelation == null) {
    		lastRelation = createIncompleteRelation(id, name);
    	}
     	lastRelation.addRelationType(findRelationTypeByString(getStartElementNameLocalPart(event)));
    }

    /**
     * Adds an inheritance, abstraction (realization) or generalization (inheritance)) relation to the system under
     * consideration.
     *
     * @param event
     */
    private void handleInheritance(XMLEvent event) {
        if (MODEL.equals(getParentElementNameLocalPart())) {
            final String id = readAttributes(event).get(ID);
            final String name = readAttributes(event).get(NAME);
        	lastRelation = createIncompleteRelation(id, name);
            lastRelation.addRelationType(findRelationTypeByString(getStartElementNameLocalPart(event)));
        }
    }

    /**
     * Keep track of the navigabilities of the assocation in order to find
     * out if the association is directed.
     *
     * @param event
     */
    private void handleAssociationEndEvent(XMLEvent event) {
        //association directed if first node !isNavigable and second node isNavigable
    	//will be used when an association edge is created
        navigabilities.push(Boolean.valueOf(readAttributes(event).get(IS_NAVIGABLE)));
    }

    /**
    * Find or create an {@link Relation} and add the {@link RelationType}.
     * @param event
    */
    private void handleDependencyEvent(XMLEvent event) {
        if (CLASS.equals(getParentElementNameLocalPart())) {
          String dependencyId = readAttributes(event).get(ID);
            if (dependencyId != null && findSystemRelationById(dependencyId) == null) {
                //create an incomplete relation if the relation does not exist yet
                lastRelation = createIncompleteRelation(dependencyId, null);
                lastRelation.addRelationType(RelationType.D);
            }
        }
    }

    /**
     * Sets the multiplicity of an association end.
     * @param event
     */
    private void handleMultiplicityRangeEvent(XMLEvent event) {
        if (!events.empty() && getParentElementNameLocalPart().equals(ASSOCIATION_END)) {
            int lower = Integer.parseInt(readAttributes(event).get(LOWER));
            int upper = Integer.parseInt(readAttributes(event).get(UPPER));
            if (lastRelation.getCardinalityLeft() == null) {
            	lastRelation.setCardinalityLeft(new Cardinality(lower, upper));
            } else {
            	lastRelation.setCardinalityRight(new Cardinality(lower, upper));
            }
        }
    }
    
    /**
     * Find the node in the system. If the node does not exist, create one and add to the system.
     * If the Node is incomplete (name == null), complete it.
     * @param event
     */
    private void createAndAddNode(XMLEvent event) {
        final Map<String, String> attributes = readAttributes(event);
        String id = attributes.get(ID);
        String type = getStartElementNameLocalPart(event);
        if (id != null) {
            lastNode = findOrCreateSystemNodeById(type, id);
            if (lastNode.getName() == null) { //node is incomplete
            	completeNodeAttributes(lastNode, event);
            }
        }
    }

    private void setSourceOrTargetNode(XMLEvent event) {
        final String idref = readAttributes(event).get(IDREF);
        String type = getStartElementNameLocalPart(event);   	
    	lastNode = findOrCreateSystemNodeById(type, idref);
    	sourceAndTarget.push(lastNode);
        if (sourceAndTarget.size() == 2) {
        	addEdgeToSystem(event);
        }        
    }

    private void setAttributeType(XMLEvent event) {    
    	Node sourceNode = lastNode;
    	final String typeRefId = readAttributes(event).get(IDREF);
    	final String attributeType = getStartElementNameLocalPart(event); //Class or Interface
        lastNode = findOrCreateSystemNodeById(attributeType, typeRefId);
        //set the attribute type of the node attribute
    	setNodeAttributeType(lastNode);
    	//set attribute relation
    	setAttributeRelation(event, sourceNode, lastNode);
    }

  	/**
 	 * @param event
 	 */
 	private void setNodeAttributeType(Node node) {
         lastAttribute.setType(node);
 	}

 	private void setAttributeRelation(XMLEvent event, Node sourceNode, Node targetNode) {
 //       final String attributeId = readAttributes(events.peek()).get(ID); //use the id of the attribute in the relations-id
        sourceAndTarget.push(sourceNode);
        sourceAndTarget.push(targetNode);
        lastRelation = system.getEdge(lastNode, targetNode);
        if (lastRelation == null) {
        	lastRelation = new Relation("temp", null);
        }
        String parentType = getParentElementNameLocalPart();
        lastRelation.getRelationTypes().add(findRelationTypeByString(parentType));
        addEdgeToSystem(event);
	}

 	/**
	 * @param event
	 */
	private void setParameterType(XMLEvent event) {
		final String typeRefId = readAttributes(event).get(IDREF);
		final String kind = readAttributes(events.peek()).get(KIND);
        final String ParameterType = getStartElementNameLocalPart(event); //Class or Interface
        final Node sourceNode = lastNode;
        final Node targetNode = findOrCreateSystemNodeById(ParameterType, typeRefId);
        if (kind.equals("return")) {
        	setMethodReturnType(lastMethod, targetNode);
        	setReturnRelation(event, sourceNode, targetNode);
        }  else {
        	setMethodParameterType(lastParameter, targetNode);
	        lastParameter.setType(targetNode);
	        setParameterRelation(event, sourceNode, targetNode);
         }
	}
	
	/**
	 * @param method
	 * @param targetNode
	 */
	private void setMethodReturnType(Method method, Node targetNode) {
       	method.setReturnType(targetNode);
	}

	private void setReturnRelation(XMLEvent event, Node sourceNode, Node targetNode) {
        sourceAndTarget.push(sourceNode);
        sourceAndTarget.push(targetNode);
        lastRelation = system.getEdge(lastNode, targetNode);
        if (lastRelation == null) {
        	lastRelation = new Relation("temp", null);
        }
        lastRelation.getRelationTypes().add(RelationType.R);
        addEdgeToSystem(event);		
		
	}

	private void setMethodParameterType(Parameter parameter, Node targetNode) {
       	parameter.setType(targetNode);
	}
	
	private void setParameterRelation(XMLEvent event, Node sourceNode, Node targetNode) {
        sourceAndTarget.push(sourceNode);
        sourceAndTarget.push(targetNode);
        lastRelation = system.getEdge(lastNode, targetNode);
        if (lastRelation == null) {
        	lastRelation = new Relation("temp", null);
        }
        lastRelation.getRelationTypes().add(RelationType.P);
        addEdgeToSystem(event);				
	}

	private void addEdgeToSystem(XMLEvent event) {
		Node targetNode = sourceAndTarget.pop();
		Node sourceNode = sourceAndTarget.pop();
	Relation relation = system.getEdge(sourceNode, targetNode);
		if (relation == null) {
			system.addEdge(sourceNode, targetNode, lastRelation);
			relation = system.getEdge(sourceNode, targetNode);
		} else {
			//compare relation with lastRelation
			updateRelation(relation);
			relation.setName(sourceNode.getName() + "-" + targetNode.getName());
		}		

		addReverseRelation(event, sourceNode, targetNode);
	}

	//All kinds of help functions
	
    private Node findOrCreateSystemNodeById(String type, String id) {
        Node node = findSystemNodeById(id);
        if (node == null) {
            node = createIncompleteNode(type, id);
           	system.addVertex(node);
        }
        return node;
    }

    private Node findSystemNodeById(String id) {
        return system.vertexSet().stream()
                .filter(n -> n.getId().equals(id))
                .findFirst()
                .orElse(null);
    }

    private Relation findSystemRelationById(String id) {
        return system.edgeSet().stream()
                .filter(relation -> relation.getId().equals(id))
                .findFirst()
                .orElse(null);
    }

   /**
  	 * @param String relationType
  	 * @return
  	 */
  	private RelationType findRelationTypeByString(String relationType) {
  		switch (relationType) {
  			case ASSOCIATION:
  				return RelationType.S;
 			case ABSTRACTION:
  				return RelationType.I;
  			case GENERALIZATION:
  				return RelationType.X;
  			case ATTRIBUTE:
  				return RelationType.A;
  			default:
  				return null;
  		}
  	}

   	/**
	 * @param relation
	 */
	private void updateRelation(Relation relation) {
		//update relationtypes of existing and last relation
		for(RelationType rt : lastRelation.getRelationTypes()) {
			relation.addRelationType(rt);
		}
		//if relation was incomplete, update with properties of lastRelation
		if (relation.getName() == null) {
			relation.setId(lastRelation.getId());
			relation.setName(lastRelation.getName());
			relation.setCardinalityLeft(lastRelation.getCardinalityLeft());
			relation.setCardinalityRight(lastRelation.getCardinalityRight());
		}
	}

	/**
	 * Only processed id the association is undirected (= bidirected).
	 * @param sourceNode
	 * @param targetNode
	 */
	private void addReverseRelation(XMLEvent event, Node sourceNode, Node targetNode) {
		//if the type is association and navigabilities are true
		//add a reverse edge with the same relationtype
		Relation relation = system.getEdge(sourceNode, targetNode);
		Boolean isAssociation = relation.getRelationTypes().contains(RelationType.S);
		Boolean reverseRelationExists = system.containsEdge(targetNode, sourceNode);
		if (reverseRelationExists) {
			system.getEdge(targetNode, sourceNode).getRelationTypes().add(RelationType.S);
		} else {
			if (isAssociation && navigabilities.size() == 2) {
				Boolean bidirectional = navigabilities.pop();
				bidirectional = bidirectional && navigabilities.pop();
				if (bidirectional) {
					lastRelation = createReverseRelation(event, relation, sourceNode, targetNode);
					lastRelation.getRelationTypes().add(RelationType.S);
				}
			}
		}
	}

	private Relation createReverseRelation(XMLEvent event, Relation originalRelation, Node originalSourceNode, Node originalTargetNode) {
		Relation relation = new Relation(originalRelation.getId() + "-reversed", null);
		sourceAndTarget.push(originalTargetNode);
		sourceAndTarget.push(originalSourceNode);
		addEdgeToSystem(event);
		return relation;
	}
	
    private Node createIncompleteNode(String type, String id) {
        if (CLASS.equals(type)) {
            return new Clazz(id, null);
        } else {
            return new Interface(id, null);
        }
    }

    /**
     * Creates a new {@link Edge} with the name and id, specified in the event attributes.
     *
     * @param event the {@link XMLEvent} containing the name and id in its attributes.
     * @return the newly created {@link Edge}
     */
    private Relation createIncompleteRelation(String id, String name) {
        final Relation relation = new Relation(id, name);
        return relation;
    }

 	/**
     * Create a new node attribute with the name, type and visibility specified in the event's attributes.
     * The nodeType of the Attribute is not set yet.
     *
     * @param event .
     * @return the newly created attribute (found in the list of Nodes).
     */
    private nl.ou.dpd.domain.node.Attribute createIncompleteAttribute(XMLEvent event) {
        final Map<String, String> attributes = readAttributes(event);
        final String id = attributes.get(ID);
        final String name = attributes.get(NAME);
        final Visibility visibility = Visibility.valueOfIgnoreCase(attributes.get(VISIBILITY));
        final nl.ou.dpd.domain.node.Attribute attr = new nl.ou.dpd.domain.node.Attribute(id, name, null);
        attr.setVisibility(visibility);
        return attr;
    }

    /**
     * Create a new node method with the name, type and visibility specified in the event's attributes.
     * The Return of the Method is not set yet.
     *
     * @param event the {@link XMLEvent} containing the name and type in its attributes.
     * @return the newly created attribute (found in the list of Nodes).
     */
    private Method createIncompleteMethod(XMLEvent event) {
        final Map<String, String> attributes = readAttributes(event);
        final String id = attributes.get(ID);
        final String name = attributes.get(NAME);
        final Visibility visibility = Visibility.valueOfIgnoreCase(attributes.get(VISIBILITY));
        final Method method = new Method(id, name);
        method.setVisibility(visibility);
        return method;
    }

    /**
  	 * @param node
  	 * @param event
  	 */
  	private void completeNodeAttributes(Node node, XMLEvent event) {
         final Map<String, String> attributes = readAttributes(event);
         String type = getStartElementNameLocalPart(event);
              if (node.getName() == null) { //node is incomplete
              	node.setName(attributes.get(NAME));
                  if (CLASS.equals(type)) {
                  	node.setVisibility(Visibility.valueOfIgnoreCase(attributes.get(VISIBILITY)));
                  	node.setAbstract(Boolean.valueOf(attributes.get(IS_ABSTRACT)));
                  }
              }
  	}

    /**
     * Return an Attributes Map with the attribute name as key and the attribute value as value, retrieved from the
     * specified {@link XMLEvent}.
     *
     * @param event the {@link XMLEvent} containing the attributes.
     * @return a Map containing attributes, extracted from the {@code event}.
     */
    private Map<String, String> readAttributes(XMLEvent event) {
        Map<String, String> attributes = new HashMap<>();
        Iterator<Attribute> attrIterator = event.asStartElement().getAttributes();
        while (attrIterator.hasNext()) {
            Attribute attr = attrIterator.next();
            attributes.put(attr.getName().getLocalPart(), attr.getValue());
        }
        return attributes;
    }

    private String getParentElementNameLocalPart() {
        return getStartElementNameLocalPart(events.peek());
    }

    private String getStartElementNameLocalPart(XMLEvent event) {
        return event.asStartElement().getName().getLocalPart();
    }

    private void error(String msg, Exception cause) {
        LOGGER.error(msg, cause);
        throw new ParseException(msg, cause);
    }

}
