/**
 * 
 */
package nl.ou.dpd.data.argoxmi;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.Attribute;
import javax.xml.stream.events.XMLEvent;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import nl.ou.dpd.domain.SystemUnderConsideration;
import nl.ou.dpd.domain.edge.Cardinality;
import nl.ou.dpd.domain.edge.Edge;
import nl.ou.dpd.domain.edge.EdgeType;
import nl.ou.dpd.domain.node.Clazz;
import nl.ou.dpd.domain.node.Interface;
import nl.ou.dpd.domain.node.Node;
import nl.ou.dpd.domain.node.Visibility;
import nl.ou.dpd.exception.DesignPatternDetectorException;

/**
 * This class implements a parser for a xmi-file as generated by the ArgoUML-modelling tool (see <a href="http://argouml.tigris.org/">http://argouml.tigris.org/</a>). with a structure- and conditions part, including parsing nodes, edges, attributes and conditions.
 * If successfully, the parsing results in a {@link SystemUnderConsideration} with edges, nodes, attributes and all necessary properties that could be read in the XMI-file.
 * 
 * TODO: implement parsing of operations.  
 * 
 * @author Peter Vansweevelt
 *
 */
public class ArgoUMLSystemParser {
	
    private static final Logger LOGGER = LogManager.getLogger(ArgoUMLSystemParser.class);
    
    private SystemUnderConsideration system;
    private List<Node> nodes;
    private Stack<XMLEvent> events = new Stack<XMLEvent>();
    private nl.ou.dpd.domain.node.Attribute lastAttribute;

    public int getNumberOfNodes() {
    	return nodes.size();
    }
    
    /**
     * Parses an xmi file with the specified {@code filename}.
     *
     * @param filename the name of the file to be parsed.
     * @return a new {@link SystemUnderConsideration}.
     */
    public SystemUnderConsideration parse(String filename) {
 
		//initialize lists
		nodes = new ArrayList<Node>();
    	XMLInputFactory factory = XMLInputFactory.newInstance();
    	
    	try {
	    	InputStream input = new FileInputStream(new File(filename));
	        XMLEventReader eventReader = factory.createXMLEventReader(input);	        
	        handleEvents(eventReader);
	    } catch (XMLStreamException e) {
            final String msg = "The XMI file " + filename + " could not be parsed.";
            LOGGER.error(msg, e);
            throw new DesignPatternDetectorException(msg, e);
        } catch (FileNotFoundException e) {
            final String msg = "The XMI file " + filename + " could not be found.";
            LOGGER.error(msg, e);
            throw new DesignPatternDetectorException(msg, e);
        }    	
    	return system;
    }

	/**
	 * General method to iterate the events of the XML.
	 * @param eventReader
	 * @throws XMLStreamException 
	 */
	private void handleEvents(XMLEventReader eventReader) throws XMLStreamException {
	    while (eventReader.hasNext()) {
	    	XMLEvent event = eventReader.nextEvent();
	    	handleEvent(event);
	    }        
	}

	/**
	 * General method to handle events.
	 * Start- and endelements are only listed if there is an action bound to the event. 
	 * @param event
	 */
	private void handleEvent(XMLEvent event) {

		if (event.isStartElement()) {
			switch (event.asStartElement().getName().getLocalPart()) {
				case XMITag.MODEL:
					//Create the SystemUnderConsideration
					system = createSystem(readAttributes(event));
					events.push(event);
					break;
				case XMITag.CLASS:
				case XMITag.INTERFACE:
					handleNodeEvent(event);
					events.push(event);
					break;
				case XMITag.ATTRIBUTE:
					//create an attribute WITHOUT type (null) and add it to the attributes of Node
					Node lastNode = nodes.get(nodes.size() - 1);
					nl.ou.dpd.domain.node.Attribute attr = createUncompleteAttribute(readAttributes(event));
					lastNode.getAttributes().add(attr);
					events.push(event);
					break;
				case XMITag.ASSOCIATION:
					//create an uncomplete edge
					String associationId = readAttributes(event).get(XMIAttribute.ID);
					String associationName = readAttributes(event).get(XMIAttribute.NAME);
					system.addRealEdge(new Edge(associationId, associationName, null, null));
					//remember this event
					events.push(event);
					break;
				case XMITag.ABSTRACTION:
					handleAbstraction(event);
					//remember this event
					events.push(event);
					break;
				case XMITag.GENERALIZATION:
					handleGeneralization(event);
					//remember this event
					events.push(event);
					break;
				case XMITag.ASSOCIATION_END:
					//navigability
					if (system.getEdges().get(system.getEdges().size() - 1).getRelationType() == null) {
						String temp = readAttributes(event).get(XMIAttribute.IS_NAVIGABLE);
						if (!temp.equals("true")) {
							system.getEdges().get(system.getEdges().size() - 1).setRelationType(EdgeType.ASSOCIATION_DIRECTED);
						} else {
							system.getEdges().get(system.getEdges().size() - 1).setRelationType(EdgeType.ASSOCIATION);
						}
					} else {
						String temp = readAttributes(event).get(XMIAttribute.IS_NAVIGABLE);
//						Boolean b = Boolean.getBoolean(temp);
//						boolean bb = temp.equals("true");
 						if (system.getEdges().get(system.getEdges().size() - 1).getRelationType() == EdgeType.ASSOCIATION && temp.equals("true")) {
							system.getEdges().get(system.getEdges().size() - 1).setRelationType(EdgeType.ASSOCIATION);
						}
					}
					events.push(event);
					break;
				case XMITag.MULTIPLICITY_RANGE:
					//multiplicity of an associationEnd 
					if (!events.empty() && events.peek().asStartElement().getName().getLocalPart().equals(XMITag.ASSOCIATION_END)){
						int lower = Integer.parseInt(readAttributes(event).get(XMIAttribute.LOWER));
						int upper = Integer.parseInt(readAttributes(event).get(XMIAttribute.UPPER));
						if (system.getEdges().get(system.getEdges().size() - 1).getCardinalityLeft() == null) {
							system.getEdges().get(system.getEdges().size() - 1).setCardinalityLeft(lower, upper);
						} else {
							system.getEdges().get(system.getEdges().size() - 1).setCardinalityRight(lower, upper);						
						}
					}
					events.push(event);
					break;
				case XMITag.DATATYPE:
					//internal ArgoUML datatype of an attribute
					handleDatatypeEvent(event);
					events.push(event);
					break;
				case XMITag.DEPENDENCY:
					handleDependencyEvent(event);
					events.push(event);
					break;
			}
		}
		
		if (event.isEndElement()) {
			switch (event.asEndElement().getName().getLocalPart()) {
				case XMITag.MODEL:
				case XMITag.CLASS:
				case XMITag.INTERFACE:
				case XMITag.ATTRIBUTE:
				case XMITag.ASSOCIATION:
				case XMITag.ABSTRACTION:
				case XMITag.GENERALIZATION:
				case XMITag.ASSOCIATION_END:
				case XMITag.MULTIPLICITY_RANGE:
				case XMITag.DATATYPE:
				case XMITag.DEPENDENCY:
					events.pop();
			}
		}	
	}

	/**
	 * General method to read {@link Attribute}s of an xml-startevent.
	 * @param {@link XMLEvent}
	 * @return a Map<String, String> holding the attributes with the attribute name as key and the attribute value as value
	 */
	private Map<String, String> readAttributes(XMLEvent event) {
		//holds the attributes with the attribute name as key and the attribute value as value
		Map<String, String> attributes = new HashMap<String, String>();
		Iterator<Attribute> attrIterator = event.asStartElement().getAttributes();
		while (attrIterator.hasNext()) {
			Attribute attr = attrIterator.next();
			attributes.put(attr.getName().getLocalPart(), attr.getValue());			
		}
		return attributes;		
	}
	
	private void handleNodeEvent(XMLEvent event) {
		Node node;
		String idref;
		//look for the event one level higher
		switch(events.peek().asStartElement().getName().getLocalPart()) {
			case XMITag.MODEL:
				//this is genuine node event
				if (readAttributes(event).get(XMIAttribute.ID) != null) {
					node = findNodeById(readAttributes(event).get(XMIAttribute.ID));
					if ( node == null) {
						//node does not exist
						node = createUncompleteNode(event);
						nodes.add(node);
					}
					if (node.getName() == null) {
						//properties are not set yet
						setNodeProperties(event);
					}
				}
				break;				
			case XMITag.ASSOCIATION_END:
				//if last remembered event is associationEnd.participant, this is the type of an association end
				if (system.getEdges().get(system.getEdges().size() - 1).getLeftNode() == null) {
					system.getEdges().get(system.getEdges().size() - 1).setLeftNode(findNodeById(readAttributes(event).get(XMIAttribute.IDREF)));
				} else {
					system.getEdges().get(system.getEdges().size() - 1).setRightNode(findNodeById(readAttributes(event).get(XMIAttribute.IDREF)));						
				}
				break;
			case XMITag.ABSTRACTION:
				//if last remembered event is abstraction, this is the type of an abstraction node
				if (system.getEdges().get(system.getEdges().size() - 1).getLeftNode() == null) {
					system.getEdges().get(system.getEdges().size() - 1).setLeftNode(findNodeById(readAttributes(event).get(XMIAttribute.IDREF)));
				} else {
					system.getEdges().get(system.getEdges().size() - 1).setRightNode(findNodeById(readAttributes(event).get(XMIAttribute.IDREF)));						
				}
				break;
			case XMITag.GENERALIZATION:
				//if last remembered event is generalization, this is the type of an abstraction node
				if (system.getEdges().get(system.getEdges().size() - 1).getLeftNode() == null) {
					system.getEdges().get(system.getEdges().size() - 1).setLeftNode(findNodeById(readAttributes(event).get(XMIAttribute.IDREF)));
				} else {
					system.getEdges().get(system.getEdges().size() - 1).setRightNode(findNodeById(readAttributes(event).get(XMIAttribute.IDREF)));						
				}
				break;
			case XMITag.ATTRIBUTE:
				//if last remembered event is attribute, set the type of the attribute
				Node lastNode = nodes.get(nodes.size() - 1);
				nl.ou.dpd.domain.node.Attribute attr = lastNode.getAttributes().get(lastNode.getAttributes().size() - 1);
				idref = readAttributes(event).get(XMIAttribute.IDREF);
				node = findNodeById(idref);
				if (node == null) {
					node = createUncompleteNode(event);
					nodes.add(node);
				} 
				attr.setType(node);
				break;
			case XMITag.DEPENDENCY:
				//if last remembered event is dependency, this is the type of an abstraction node
				String dependencyId = readAttributes(events.peek()).get(XMIAttribute.ID);
				String idrefNode = readAttributes(event).get(XMIAttribute.IDREF);
				node = findNodeById(idrefNode);
				Edge edge = findEdgeById(dependencyId);
				if (node == null) {
					node = createUncompleteNode(event);
					nodes.add(node);
				} 
				if (edge.getLeftNode() == null) {
					edge.setLeftNode(findNodeById(idrefNode));
				} else {
					edge.setRightNode(findNodeById(idrefNode));						
				}
				break;	
			}
	}

	private void handleDatatypeEvent(XMLEvent event) {
		Node node;
		//look for the event one level higher
		switch(events.peek().asStartElement().getName().getLocalPart()) {
			case XMITag.ATTRIBUTE:
				//if last remembered event is attribute, set the type of the attribute
				//see http://argouml.tigris.org//profiles/uml14/default-uml14.xmi
				Node lastNode = nodes.get(nodes.size() - 1);
				nl.ou.dpd.domain.node.Attribute attr = lastNode.getAttributes().get(lastNode.getAttributes().size() - 1);
				String href = readAttributes(event).get(XMIAttribute.HREF);
				if (href.substring(href.length() - 56).equals("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087C")) {
					node = new Clazz("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087C", "Integer");
					nodes.add(node);
					attr.setType(node);
				}
				if (href.substring(href.length() - 56).equals("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087D")) {
					node = new Clazz("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087C", "UnlimitedInteger");
					nodes.add(node);
					attr.setType(node);
				}
				if (href.substring(href.length() - 56).equals("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087E")) {
					node = new Clazz("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087C", "String");
					nodes.add(node);
					attr.setType(node);
				}
				if (href.substring(href.length() - 56).equals("-84-17--56-5-43645a83:11466542d86:-8000:0000000000000880")) {
					node = new Clazz("-84-17--56-5-43645a83:11466542d86:-8000:0000000000000880", "Boolean");
					nodes.add(node);
					attr.setType(node);
				}
				break;
			}
	}
	
	private void handleAbstraction(XMLEvent event) {
		if (events.peek().asStartElement().getName().getLocalPart() == XMITag.MODEL) {
			//create an uncomplete edge
			String abstractionId = readAttributes(event).get(XMIAttribute.ID);
			Edge edge = new Edge(abstractionId, null, null, null);
			edge.setRelationType(EdgeType.REALIZATION);
			system.addRealEdge(edge);			
		}
	}
	
	private void handleGeneralization(XMLEvent event) {
		if (events.peek().asStartElement().getName().getLocalPart() == XMITag.MODEL) {
			//create an uncomplete edge
			String abstractionId = readAttributes(event).get(XMIAttribute.ID);
			Edge edge = new Edge(abstractionId, null, null, null);
			edge.setRelationType(EdgeType.INHERITANCE);
			system.addRealEdge(edge);			
		}
	}

	private void handleDependencyEvent(XMLEvent event) {
		if (events.peek().asStartElement().getName().getLocalPart() == XMITag.CLASS) {
			//create an uncomplete edge
			Map<String, String> attributes = readAttributes(event);
			String dependencyId = attributes.get(XMIAttribute.ID);
			if (dependencyId == null) {
				dependencyId = attributes.get(XMIAttribute.IDREF);
			}
			if (dependencyId != null && findEdgeById(dependencyId) == null) {//create an uncomplete edge if the edge does not exist yet
				Edge edge = new Edge(dependencyId, null, null, null);
				edge.setRelationType(EdgeType.DEPENDENCY);
				system.addRealEdge(edge);	
			}
		}		
	}
	/**
	 * Create a new {@link DesignPattern) with given name
	 * @param attributes a map of attributes holding the name
	 * @return a new DesignPattern with the specified name.
	 */
	private SystemUnderConsideration createSystem(Map<String, String> attributes) {
		String id = attributes.get(XMIAttribute.ID);
		String name = attributes.get(XMIAttribute.NAME);
		return new SystemUnderConsideration(id, name);		
	}

	/**
	 * Create a new {@link Node) with given id and type.
	 * @param an {@link XMLEvent}
	 * @return a new Node with the specified name and type.
	 */
	private Node createUncompleteNode(XMLEvent event) {
		Map<String, String> attributes = readAttributes(event);
		String id = attributes.get(XMIAttribute.ID);
		if (id == null) {
			id = attributes.get(XMIAttribute.IDREF);
		}
		Node node;
		if (event.asStartElement().getName().getLocalPart() == XMITag.CLASS) {
			node = new Clazz(id, null);
		} else {
			//interface
			node = new Interface(id, null);			
		}
		return node;
	}
	
	/**
	 * Create a new {@link Interface) with given id and type.
	 * @param attributes a map of attributes holding the id and type
	 * @return a new Node with the specified name and type.
	 */
	private void setNodeProperties(XMLEvent event) {
		Map<String, String> attributes = readAttributes(event);
		String id = attributes.get(XMIAttribute.ID);
		String name = attributes.get(XMIAttribute.NAME);
		Boolean isRoot = Boolean.valueOf(attributes.get(XMIAttribute.IS_ROOT));
		Boolean isLeaf = Boolean.valueOf(attributes.get(XMIAttribute.IS_LEAF));
		Boolean isActive = Boolean.valueOf(attributes.get(XMIAttribute.IS_ACTIVE));
		Visibility visibility = findVisibilityByName(attributes.get(XMIAttribute.VISIBILITY));
		Boolean isAbstract = Boolean.valueOf(attributes.get(XMIAttribute.IS_ABSTRACT));

		if (event.asStartElement().getName().getLocalPart() == XMITag.CLASS) {
			Clazz clazz = (Clazz) findNodeById(attributes.get(XMIAttribute.ID));
			clazz.setName(name);
			clazz.setVisibility(visibility);
			clazz.setRoot(isRoot);
			clazz.setLeaf(isLeaf);
			clazz.setAbstract(isAbstract);
			clazz.setActive(isActive);
		} else {
			//interface
			Interface iface = (Interface) findNodeById(attributes.get(XMIAttribute.ID));
			iface.setName(name);
			iface.setRoot(isRoot);
			iface.setLeaf(isLeaf);
			iface.setActive(isActive);
		}
	}

/**
	 * Checks if the id of the new {@link Node) is unique in this pattern.
	 * @param node
	 * @return true if the node is unique in this pattern, false otherwise.
	 */
	private boolean nodeIdIsUnique(Node node) {
		for (Node n : nodes) {
			if (n.getId().equals(node.getId())) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Create a new node-attribute with the name and type specified in the Map.
	 * @param attributes a Map of attributes of the Attribute XML StartEvent.
	 * @return a new node-attribute with the specified name and type (found in the list of Nodes).
	 */
	private nl.ou.dpd.domain.node.Attribute createUncompleteAttribute(Map<String, String> attributes) {
		String id = attributes.get(XMIAttribute.ID);
		String name = attributes.get(XMIAttribute.NAME);
		Visibility visibility = findVisibilityByName(attributes.get(XMIAttribute.VISIBILITY));
		nl.ou.dpd.domain.node.Attribute attr = new nl.ou.dpd.domain.node.Attribute(id, name, null);
		attr.setVisibility(visibility);;
		return attr;
	}

	/**
	 * Find a Node by id.
	 * @param id the id as a String
	 * @return the node object with the id of 'id'
	 */
	private Node findNodeById(String id) {
		for (Node n : nodes) {
			if (n.getId().equals(id)) {
				return n;
			}
		}
		return null;
	}

	/**
	 * Find an Edge by id.
	 * @param id the id as a String
	 * @return the edge object with the id of 'id'
	 */
	private Edge findEdgeById(String id) {
		for (Edge e : system.getEdges()) {
			if (e.getId().equals(id)) {
				return e;
			}
		}
		return null;
	}

	private Visibility findVisibilityByName(String visibilityName) {
		for (Visibility visibility : Visibility.values()) {
		  if (visibility.toString().contains(visibilityName.toUpperCase())) {
			  return visibility;
		  }
		}
		return null;
	}
	
    private void error(String message) {
        final Exception e = new XMLStreamException();
        LOGGER.error(message);
        throw new DesignPatternDetectorException(message, e);
    }
}
