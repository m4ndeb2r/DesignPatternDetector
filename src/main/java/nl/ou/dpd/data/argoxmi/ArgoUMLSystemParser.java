package nl.ou.dpd.data.argoxmi;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.Attribute;
import javax.xml.stream.events.XMLEvent;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import nl.ou.dpd.domain.SystemUnderConsideration;
import nl.ou.dpd.domain.edge.Edge;
import nl.ou.dpd.domain.edge.EdgeType;
import nl.ou.dpd.domain.node.Clazz;
import nl.ou.dpd.domain.node.Interface;
import nl.ou.dpd.domain.node.Node;
import nl.ou.dpd.domain.node.Visibility;
import nl.ou.dpd.exception.DesignPatternDetectorException;

/**
 * This class implements a parser for a xmi-file as generated by the ArgoUML-modelling tool (see <a href="http://argouml.tigris.org/">http://argouml.tigris.org/</a>). with a structure- and conditions part, including parsing nodes, edges, attributes and conditions.
 * If successfully, the parsing results in a {@link SystemUnderConsideration} with edges, nodes, attributes and all necessary properties that could be read in the XMI-file.
 * 
 * TODO: implement parsing of operations.  
 * 
 * @author Peter Vansweevelt
 *
 */
public class ArgoUMLSystemParser {
	//attributes of the XMI
	final String NAME = "name";
	final String ID = "xmi.id";
	final String VISIBILITY = "visibility";
	final String IS_ROOT = "isRoot";
	final String IS_LEAF = "isLeaf";
	final String IS_ABSTRACT = "isAbstract";
	final String IS_ACTIVE = "isActive";
	final String IDREF = "xmi.idref";
	final String LOWER = "lower";
	final String UPPER = "upper";
	final String IS_NAVIGABLE = "isNavigable";
	final String HREF= "href";
	//tags of the XMI
	final String MODEL = "Model";
	final String CLASS = "Class";
	final String INTERFACE = "Interface";
	final String ATTRIBUTE = "Attribute";
	final String OPERATION = "Operation";
	final String ASSOCIATION ="Association";
	final String ASSOCIATION_END = "AssociationEnd";
	final String MULTIPLICITY_RANGE = "MultiplicityRange";
	final String MULTIPLICITY_DOT_RANGE = "Multiplicity.range";
	final String ASSOCIATION_END_DOT_PARTICIPANT = "AssociationEnd.participant";
	final String ABSTRACTION = "Abstraction";
	final String DEPENDENCY = "Dependency";
	final String DEPENDENCY_DOT_CLIENT = "Dependency.client";
	final String DEPENDENCY_DOT_SUPPLIER = "Dependency.supplier";
	final String GENERALIZATION = "Generalization";
	final String GENERALIZATION_DOT_CHILD = "Generalization.child";
	final String GENERALIZATION_DOT_PARENT = "Generalization.parent";
	final String NAMESPACE_DOT_OWNED_ELEMENT = "Namespace.ownedElement";
	final String DATATYPE = "DataType";
	
    private static final Logger LOGGER = LogManager.getLogger(ArgoUMLSystemParser.class);
    
    private SystemUnderConsideration system;
    private List<Node> nodes;
    private Stack<XMLEvent> events = new Stack<XMLEvent>();

    public int getNumberOfNodes() {
    	return nodes.size();
    }
    
    /**
     * Parses an xmi file with the specified {@code filename}.
     *
     * @param filename the name of the file to be parsed.
     * @return a new {@link SystemUnderConsideration}.
     */
    public SystemUnderConsideration parse(String filename) {
 
		//initialize lists
		nodes = new ArrayList<Node>();
    	XMLInputFactory factory = XMLInputFactory.newInstance();
    	
    	try {
	    	InputStream input = new FileInputStream(new File(filename));
	        XMLEventReader eventReader = factory.createXMLEventReader(input);	        
	        handleEvents(eventReader);
	    } catch (XMLStreamException e) {
            final String msg = "The XMI file " + filename + " could not be parsed.";
            LOGGER.error(msg, e);
            throw new DesignPatternDetectorException(msg, e);
        } catch (FileNotFoundException e) {
            final String msg = "The XMI file " + filename + " could not be found.";
            LOGGER.error(msg, e);
            throw new DesignPatternDetectorException(msg, e);
        }    	
    	return system;
    }

	/**
	 * General method to iterate the events of the XML.
	 * @param eventReader
	 * @throws XMLStreamException 
	 */
	private void handleEvents(XMLEventReader eventReader) throws XMLStreamException {
	    while (eventReader.hasNext()) {
	    	XMLEvent event = eventReader.nextEvent();
	    	handleEvent(event);
	    }        
	}

	/**
	 * General method to handle events.
	 * Start- and end elements are only listed if there is an action bound to the event. 
	 * @param event
	 */
	private void handleEvent(XMLEvent event) {

		if (event.isStartElement()) {
			switch (event.asStartElement().getName().getLocalPart()) {
				case MODEL:
					//Create the SystemUnderConsideration
					system = createSystem(event);
					events.push(event);
					break;
				case CLASS:
				case INTERFACE:
					handleNodeEvent(event);
					events.push(event);
					break;
				case ATTRIBUTE:
					handleAttributeEvent(event);
					events.push(event);
					break;
				case ASSOCIATION:
					handleAssociationEvent(event);
					events.push(event);
					break;
				case ABSTRACTION:
					handleAbstraction(event);
					events.push(event);
					break;
				case GENERALIZATION:
					handleGeneralization(event);
					events.push(event);
					break;
				case ASSOCIATION_END:
					//navigability
					handleAssociationEndEvent(event);
					events.push(event);
					break;
				case MULTIPLICITY_RANGE:
					handleMultiplicityRangeEvent(event);
					events.push(event);
					break;
				case DATATYPE:
					//internal ArgoUML datatype of an attribute
					handleDatatypeEvent(event);
					events.push(event);
					break;
				case DEPENDENCY:
					handleDependencyEvent(event);
					events.push(event);
					break;
				default:
			}
		}
		
		if (event.isEndElement()) {
			switch (event.asEndElement().getName().getLocalPart()) {
				case MODEL:
				case CLASS:
				case INTERFACE:
				case ATTRIBUTE:
				case ASSOCIATION:
				case ABSTRACTION:
				case GENERALIZATION:
				case ASSOCIATION_END:
				case MULTIPLICITY_RANGE:
				case DATATYPE:
				case DEPENDENCY:
					events.pop();
				default:
			}
		}	
	}

	private void handleNodeEvent(XMLEvent event) {
		//look for the event one level higher
		switch(events.peek().asStartElement().getName().getLocalPart()) {
			case MODEL:
				//this is genuine node event
				createAndAddNode(event);
			break;				
			case ASSOCIATION_END:
				//if last remembered event is associationEnd.participant, this is the type of an association end
				setLeftOrRightNode(event);
				break;
			case ABSTRACTION:
				//if last remembered event is abstraction, this is the type of an abstraction node
				setLeftOrRightNode(event);
				break;
			case GENERALIZATION:
				//if last remembered event is generalization, this is the type of an abstraction node
				setLeftOrRightNode(event);
				break;
			case ATTRIBUTE:
				//if last remembered event is attribute, set the type of the attribute
				setAttributeType(event);
				break;
			case DEPENDENCY:
				//if last remembered event is dependency, this is the type of an abstraction node
				setDependencyNode(event);
				break;
			default:
			}
	}

	/**
	 * Create a new {@link SystemUnderConsideration) with given id and name
	 * @param attributes a map of attributes holding the name
	 * @return a new SystemUnderConsideration with the specified id and name.
	 */
	private SystemUnderConsideration createSystem(XMLEvent event) {
		String id = readAttributes(event).get(ID);
		String name = readAttributes(event).get(NAME);
		return new SystemUnderConsideration(id, name);		
	}
	
	//add an attribute
	private void handleAttributeEvent(XMLEvent event) {
		//create an attribute WITHOUT type (null) and add it to the attributes of Node.
		//A type will be added as a special handling of the Class/Interface event
		Node node = findNodeById(readAttributes(events.peek()).get(ID));		
		nl.ou.dpd.domain.node.Attribute attr = createUncompleteAttribute(event);
		node.getAttributes().add(attr);
	}
	
	//add an association
	private void handleAssociationEvent(XMLEvent event) {
		system.addRealEdge(createUncompleteEdge(event));
	}
	
	//add an abstraction
	private void handleAbstraction(XMLEvent event) {
		if (events.peek().asStartElement().getName().getLocalPart() == MODEL) {
			//create an uncomplete edge
			Edge edge = createUncompleteEdge(event);
			edge.setRelationType(EdgeType.REALIZATION);
			system.addRealEdge(edge);			
		}
	}
	
	//add a generalization
	private void handleGeneralization(XMLEvent event) {
		if (events.peek().asStartElement().getName().getLocalPart() == MODEL) {
			//create an uncomplete edge
			Edge edge = createUncompleteEdge(event);
			edge.setRelationType(EdgeType.INHERITANCE);
			system.addRealEdge(edge);			
		}
	}

	//set the kind of asociation
	private void handleAssociationEndEvent(XMLEvent event) {
		//association directed if first node isNavigable == false and second node isNavigable == true
		Edge edge = getLastEdge();
		if (edge != null && edge.getRelationType() == null) {
			String temp = readAttributes(event).get(IS_NAVIGABLE);
			if (!temp.equals("true")) {
				edge.setRelationType(EdgeType.ASSOCIATION_DIRECTED);
			} else {
				edge.setRelationType(EdgeType.ASSOCIATION);
			}
		} else {
			String temp = readAttributes(event).get(IS_NAVIGABLE);
			if (edge.getRelationType() == EdgeType.ASSOCIATION && temp.equals("true")) {
				edge.setRelationType(EdgeType.ASSOCIATION);
			}
		}
	}

	//set the multipicity of an association end
	private void handleMultiplicityRangeEvent(XMLEvent event) {
		//multiplicity of an associationEnd
		Edge edge = getLastEdge();
		if (!events.empty() && events.peek().asStartElement().getName().getLocalPart().equals(ASSOCIATION_END)){
			int lower = Integer.parseInt(readAttributes(event).get(LOWER));
			int upper = Integer.parseInt(readAttributes(event).get(UPPER));
			if (edge.getCardinalityLeft() == null) {
				edge.setCardinalityLeft(lower, upper);
			} else {
				edge.setCardinalityRight(lower, upper);						
			}
		}
	}

	//set the type of an attribute
	private void handleDatatypeEvent(XMLEvent event) {
		Node node;
		//look for the event one level higher
		switch(events.peek().asStartElement().getName().getLocalPart()) {
			case ATTRIBUTE:
				//if last remembered event is attribute, set the type of the attribute
				//see http://argouml.tigris.org//profiles/uml14/default-uml14.xmi
				Node lastNode = nodes.get(nodes.size() - 1);
				nl.ou.dpd.domain.node.Attribute attr = lastNode.getAttributes().get(lastNode.getAttributes().size() - 1);
				String href = readAttributes(event).get(HREF);
				if (href.substring(href.length() - 56).equals("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087C")) {
					node = new Clazz("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087C", "Integer");
					nodes.add(node);
					attr.setType(node);
				}
				if (href.substring(href.length() - 56).equals("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087D")) {
					node = new Clazz("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087C", "UnlimitedInteger");
					nodes.add(node);
					attr.setType(node);
				}
				if (href.substring(href.length() - 56).equals("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087E")) {
					node = new Clazz("-84-17--56-5-43645a83:11466542d86:-8000:000000000000087C", "String");
					nodes.add(node);
					attr.setType(node);
				}
				if (href.substring(href.length() - 56).equals("-84-17--56-5-43645a83:11466542d86:-8000:0000000000000880")) {
					node = new Clazz("-84-17--56-5-43645a83:11466542d86:-8000:0000000000000880", "Boolean");
					nodes.add(node);
					attr.setType(node);
				}
				break;
			}
	}
	
	//add a dependency edge 
	private void handleDependencyEvent(XMLEvent event) {
		if (events.peek().asStartElement().getName().getLocalPart() == CLASS) {
			//create an uncomplete edge
			Map<String, String> attributes = readAttributes(event);
			String dependencyId = getIdOrIdref(attributes);
			if (dependencyId != null && findEdgeById(dependencyId) == null) {//create an uncomplete edge if the edge does not exist yet
				Edge edge = new Edge(dependencyId, null, null, null);
				edge.setRelationType(EdgeType.DEPENDENCY);
				system.addRealEdge(edge);	
			}
		}		
	}

	//Create a node with the specified id if it does not exist and add it to the nodes -list.
	//Set the properties of the (new or existing) node.
	private void createAndAddNode(XMLEvent event) {
		Node node = null;
		if (readAttributes(event).get(ID) != null) {
			node = findNodeById(readAttributes(event).get(ID));
			if (node == null) {
				//node does not exist
				node = createUncompleteNode(event);
				nodes.add(node);
			}
			if (node.getName() == null) {
				//properties are not set yet
				setNodeProperties(event);
			}
		}
	}

	private void setLeftOrRightNode(XMLEvent event) {
		Edge edge = getLastEdge();
		if (edge.getLeftNode() == null) {
			edge.setLeftNode(findNodeById(readAttributes(event).get(IDREF)));
		} else {
			edge.setRightNode(findNodeById(readAttributes(event).get(IDREF)));						
		}
	}
	
	private void setAttributeType (XMLEvent event) {
		nl.ou.dpd.domain.node.Attribute attr = getLastNode().getAttributes().get(getLastNode().getAttributes().size() - 1);
		String idref = readAttributes(event).get(IDREF);
		Node node = findNodeById(idref);
		if (node == null) {
			node = createUncompleteNode(event);
			nodes.add(node);
		} 
		attr.setType(node);

	}
	
	private void setDependencyNode(XMLEvent event) {
		String dependencyId = readAttributes(events.peek()).get(ID);
		String idrefNode = readAttributes(event).get(IDREF);
		Node node = findNodeById(idrefNode);
		Edge edge = findEdgeById(dependencyId);
		if (node == null) {
			node = createUncompleteNode(event);
			nodes.add(node);
		} 
		if (edge.getLeftNode() == null) {
			edge.setLeftNode(findNodeById(idrefNode));
		} else {
			edge.setRightNode(findNodeById(idrefNode));						
		}
	}
	
	private Edge createUncompleteEdge(XMLEvent event) {
		String id = readAttributes(event).get(ID);
		String name = readAttributes(event).get(NAME);
		Edge edge = new Edge(id, name, null, null);
		return edge;
	}
		
	/**
	 * Create a new {@link Node) with given id and type.
	 * @param an {@link XMLEvent}
	 * @return a new Node with the specified name and type.
	 */
	private Node createUncompleteNode(XMLEvent event) {
		Map<String, String> attributes = readAttributes(event);
		String id = getIdOrIdref(attributes);
		Node node;
		if (event.asStartElement().getName().getLocalPart() == CLASS) {
			node = new Clazz(id, null);
		} else {
			//interface
			node = new Interface(id, null);			
		}
		return node;
	}
	
	/**
	 * Create a new node-attribute with the name and type specified in the Map.
	 * @param attributes a Map of attributes of the Attribute XML StartEvent.
	 * @return a new node-attribute with the specified name and type (found in the list of Nodes).
	 */
	private nl.ou.dpd.domain.node.Attribute createUncompleteAttribute(XMLEvent event) {
		Map<String, String> attributes = readAttributes(event);
		String id = attributes.get(ID);
		String name = attributes.get(NAME);
		Visibility visibility = findVisibilityByName(attributes.get(VISIBILITY));
		nl.ou.dpd.domain.node.Attribute attr = new nl.ou.dpd.domain.node.Attribute(id, name, null);
		attr.setVisibility(visibility);;
		return attr;
	}

	/**
	 * Create a new {@link Interface) with given id and type.
	 * @param attributes a map of attributes holding the id and type
	 * @return a new Node with the specified name and type.
	 */
	private void setNodeProperties(XMLEvent event) {
		Map<String, String> attributes = readAttributes(event);
		String name = attributes.get(NAME);
		Boolean isRoot = Boolean.valueOf(attributes.get(IS_ROOT));
		Boolean isLeaf = Boolean.valueOf(attributes.get(IS_LEAF));
		Boolean isActive = Boolean.valueOf(attributes.get(IS_ACTIVE));
		Visibility visibility = findVisibilityByName(attributes.get(VISIBILITY));
		Boolean isAbstract = Boolean.valueOf(attributes.get(IS_ABSTRACT));

		if (event.asStartElement().getName().getLocalPart() == CLASS) {
			Clazz clazz = (Clazz) findNodeById(attributes.get(ID));
			clazz.setName(name);
			clazz.setVisibility(visibility);
			clazz.setRoot(isRoot);
			clazz.setLeaf(isLeaf);
			clazz.setAbstract(isAbstract);
			clazz.setActive(isActive);
		} else {
			//interface
			Interface iface = (Interface) findNodeById(attributes.get(ID));
			iface.setName(name);
			iface.setRoot(isRoot);
			iface.setLeaf(isLeaf);
			iface.setActive(isActive);
		}
	}

	/**
	 * Find a Node by id.
	 * @param id the id as a String
	 * @return the node object with the id of 'id'
	 */
	private Node findNodeById(String id) {
		for (Node n : nodes) {
			if (n.getId().equals(id)) {
				return n;
			}
		}
		return null;
	}

	/**
	 * Find an Edge by id.
	 * @param id the id as a String
	 * @return the edge object with the id of 'id'
	 */
	private Edge findEdgeById(String id) {
		for (Edge e : system.getEdges()) {
			if (e.getId().equals(id)) {
				return e;
			}
		}
		return null;
	}

	private Visibility findVisibilityByName(String visibilityName) {
		for (Visibility visibility : Visibility.values()) {
		  if (visibility.toString().contains(visibilityName.toUpperCase())) {
			  return visibility;
		  }
		}
		return null;
	}
	
	
	private String getIdOrIdref(Map<String, String> attributes) {
		String id = attributes.get(ID);
		if (id == null) {
			id = attributes.get(IDREF);
		}
		return id;

	}

	private Edge getLastEdge() {
		if (system.getEdges().isEmpty()) {
			return null;
		}
		return system.getEdges().get(system.getEdges().size() - 1);
	}

	private Node getLastNode() {
		return nodes.get(nodes.size() - 1);
	}

	/**
	 * General method to read {@link Attribute}s of an xml-startevent.
	 * @param {@link XMLEvent}
	 * @return a Map<String, String> holding the attributes with the attribute name as key and the attribute value as value
	 */
	private Map<String, String> readAttributes(XMLEvent event) {
		//holds the attributes with the attribute name as key and the attribute value as value
		Map<String, String> attributes = new HashMap<String, String>();
		Iterator<Attribute> attrIterator = event.asStartElement().getAttributes();
		while (attrIterator.hasNext()) {
			Attribute attr = attrIterator.next();
			attributes.put(attr.getName().getLocalPart(), attr.getValue());			
		}
		return attributes;		
	}
}
