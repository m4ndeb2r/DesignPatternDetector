package nl.ou.dpd.domain.matching;

import nl.ou.dpd.domain.DesignPattern;
import nl.ou.dpd.domain.SystemUnderConsideration;
import nl.ou.dpd.domain.node.Node;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * A helper class for testing purposes.
 *
 * @author Martin de Boer
 * @author Peter Vansweevelt
 */
public class TestHelper {

    /**
     * Temporary method to print feedback, generated by the pattern instpector for a certain system and pattern.
     * <p>
     * NOTE: using this method in your unit test or integration test is a 'code smell'. Visual checking of the
     * validity of your code does not belong in an automated test. This method is here just for temporary convenience
     * reasons.
     *
     * @param designPattern    the design pattern to print the feedback for
     * @param system           the system under consideration that was analysed byt the pattern inspector
     * @param patternInspector the pattern inspector that analysed the system in search for design patterns
     * @deprecated This method is here just for temporary convenience reasons.
     */
    @Deprecated
    public static void printFeedback(
            DesignPattern designPattern,
            SystemUnderConsideration system,
            PatternInspector patternInspector) {

        final PatternInspector.MatchingResult matchingResult = patternInspector.getMatchingResult();

        final List<Solution> solutions = matchingResult.getSolutions();
        solutions.forEach(solution -> {
            System.out.println("---------------------------------------");
            System.out.println(solution.getDesignPatternName());
            System.out.println("---------------------------------------");
            solution.getMatchingNodeNames().forEach(names -> System.out.println(names[0] + " matches " + names[1]));
        });

        System.out.println("\n---------------------------------------");
        System.out.println(designPattern.getName() + " feedback");
        System.out.println("---------------------------------------");
        final Feedback feedback = matchingResult.getFeedback();

        System.out.println("Node feedback:");
        final Set<Node> nodes = new HashSet<>();
        system.edgeSet().iterator().forEachRemaining(r -> {
            nodes.add(system.getEdgeSource(r));
            nodes.add(system.getEdgeTarget(r));
        });
        nodes.iterator().forEachRemaining(node -> {
            System.out.println("\n\tNode: " + node.getName());
            feedback.getFeedbackMessages(node, FeedbackType.INFO).forEach(s -> System.out.println("\t- " + s));
            feedback.getFeedbackMessages(node, FeedbackType.MATCH).forEach(s -> System.out.println("\t- " + s));
            feedback.getFeedbackMessages(node, FeedbackType.MISMATCH).forEach(s -> System.out.println("\t- " + s));
            feedback.getFeedbackMessages(node, FeedbackType.NOT_ANALYSED).forEach(s -> System.out.println("\t- " + s));
        });

        System.out.println("\nRelation feedback:");
        system.edgeSet().iterator().forEachRemaining(r -> {
            System.out.println("\n\tRelation: " + r.getName());
            feedback.getFeedbackMessages(r, FeedbackType.INFO).forEach(s -> System.out.println("\t- " + s));
            feedback.getFeedbackMessages(r, FeedbackType.MATCH).forEach(s -> System.out.println("\t- " + s));
            feedback.getFeedbackMessages(r, FeedbackType.MISMATCH).forEach(s -> System.out.println("\t- " + s));
            feedback.getFeedbackMessages(r, FeedbackType.NOT_ANALYSED).forEach(s -> System.out.println("\t- " + s));
        });
    }

    /**
     * Finds out if the specified system node and and the specified pattern node match at least once in the specified
     * solutions.
     *
     * @param solutions       the solutions to consider
     * @param systemNodeName  the name of the system node to find
     * @param patternNodeName the name of the pattern node to find
     * @return {@code true} if this match exists.
     */
    public static boolean areMatchingNodes(List<Solution> solutions, String systemNodeName, String patternNodeName) {
        for (Solution solution : solutions) {
            for (String[] names : solution.getMatchingNodeNames()) {
                if (names[0].equals(systemNodeName) && names[1].equals(patternNodeName)) {
                    return true;
                }
            }
        }
        return false;
    }

}
